<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!--
 Copyright (C) 2007 Sun Microsystems, Inc. All rights reserved. Use is
 subject to license terms.
-->

<html>
  <head>
    <title></title>
  </head>
  <body>
This package contains classes that are useful for binding to Swing components.
The rest of this document outlines how to bind to the various components.

<h3>JCheckBox</h3>

The primary property to bind is the "selected" property. The following
illustrates creating a binding targetting a {@code JCheckBox} and specifying 
it should not disable if the source contains an incomplete path:

<pre>
  Binding binding = new Binding(source, sourceExpression, jCheckBox, "selected");
  binding.setParameter(ParameterKeys.DISABLE_ON_INCOMPLETE_PATH, false);
</pre>

<h3><a name="JComboBoxBinding"></a>JComboBox</h3>

<!-- PENDING(shannonh) - this is really hard to understand -->

Binding to a {@code JComboBox} is a two phase process. You first bind
to the "elements" property. The "elements" property specifies the
contents of the {@code JComboBox}:

<pre>
  List<BugTypes> bugTypes;
  // Create the binding from the List to the JComboBox
  Binding binding = new Binding(bugTypes, null, jComboBox, "elements");
  // Specify that each element is to be shown using the 'description'
  // property. If this is not specified, the elements in the list are
  // used directly.
  binding.addChildBinding("${description}", null);
</pre>

The next step is to bind to the selection. There are two ways to do this.
The first is to bind to an element of this list. This is useful if
the object controlling the selection property is of the same type as that
of the elements of the {@code JComboBox}:

<pre>
  Binding binding = new Binding(selection, "${bugType}", 
                                jComboBox, "selectedElement");
  // Specify that each element is to be shown using the 'description'
  // property. If this is not specified, the elements in the list are
  // used used directly.
  binding.addChildBinding("${description}", null);
</pre>

The second option is to bind the selection to a property of the elements
in the list. This involves binding to the "selectedElementProperty" and 
specifying the expression to apply to each element when binding to the elements.
The following example illustrates this:

<pre>
  List<BugTypes> bugTypes;
  // Create the binding from the List to the JComboBox
  Binding binding = new Binding(bugTypes, null, jComboBox, "elements");
  // Specify that the "selectedElementProperty" corresponds to
  // selectedObject.id.
  binding.setParameter(ParameterKeys.COMBOBOX_SELECTED_OBJECT_PROPERTY, "${id}");

  // Bind to the selection
  binding = new Binding(source, "${id}", jComboBox, "selectedElementProperty");
</pre>

<h3>JList</h3>

The primary property to bind is the "elements" property. Binding to
the "elements" property results in creating and setting a custom
{@code ListModel} on the target {@code JList}. The source 
property must resolve to a {@code List}. If the source property resolves
to an {@code ObservableList}, the {@code ListModel} tracks changes as 
appropriate. A specific property can be specified for each element using
a child binding. The following illustrates creating a binding 
targetting a {@code JList}. The value for each element is obtained 
using the 'firstName' property of each {@code Customer}.

<pre>
  ObservableList<Customer> customers;
  // Create the binding from the List to the JList.
  Binding binding = new Binding(customers, null, jList, "elements");
  // Specify getValueAt is to return the 'firstName' property of
  // each element.
  binding.addChildBinding("${firstName}", null);
</pre>

The property delegate for {@code JList} also provides support for the
"selectedElement" and "selectedElements" properties. The "selectedElement"
property corresponds to the selected element (in terms of an element of
the {@code List} bound to the "elements" property). The "selectedElements"
property is a {@code List} of the selected elements. Both values change
as the selection of the {@code JList} is modified.

<h3>JSlider</h3>

The primary property to bind is the "value" property. The following
illustrates creating a binding targetting a {@code JSlider}. As disable
on incomplete path has not been specified, the slider disables if the
source path is incomplete.

<pre>
  Binding binding = new Binding(source, sourceExpression, jSlider, "value");
</pre>

<h3>JTable</h3>

{@code JTable} provides similar properties to that of {@code JList}; the
"elements" properties, of type {@code List}, specifies the contents of
the {@code JTable} (or more correctly, the {@code TableModel}), and
the "selectedElement" and "selectedElements" properties may be used to
track changes in the selection. When binding to a {@code JTable}, you
must specify how the value for each column is obtained. This is done
using the binding property {@code TableColumnParameter}. The following
illustrates creating a binding targetting a {@code JTable}. Two columns
are created, the first using the property "firstName", and the second
"lastName".

<pre>
  ObservableList<Customer> customers;
  // Create the binding from the List to the JTable.
  Binding binding = new Binding(customers, null, jTable, "elements");
  // Specify the first column should use the "firstName" property
  binding.addChildBinding("${firstName}", null).setParameter(ParameterKeys.COLUMN, 0);
  // Specify the second column should use the "lastName" property
  binding.addChildBinding("${lastName}", null).setParameter(ParameterKeys.COLUMN, 1);
</pre>

<h3>JTextComponent</h3>

The primary property to bind to is the "text" property. By default,
the "text" property is updated when enter is pressed, or focus is lost. This
may be changed using the binding property {@code TextChangeStrategyParameter}.
The following illustrates creating a binding targetting a {@code JTextField}. 
The "text" property of the {@code JTextField} is updated anytime the
{@code Document} of the {@code JTextComponent} changes.

<pre>
  Binding binding = new Binding(source, sourceExpression, jTextField, "text");
  binding.setParameter(ParameterKeys.TEXT_CHANGE_STRATEGY,
                       TextChangeStrategy.ON_TYPE);
</pre>

<h3><a name="JTreeBinding">JTree</h3>

The primary property to bind to is the "root" property. The "root" 
specifies the root object of the tree (or more correctly, the 
{@code TreeModel}). Use child bindings to specify how children of the root,
and other objects in the graph, are obtained. The child bindings must
resolve to {@code List}s, and preferrably {@code ObservableList}s. The
following illustrates creating a binding targetting a {@code JTree}. 
For nodes in the tree of type {@code Manager}, the "reports" property is
used to locate children.

<pre>
  Manager root;
  Binding binding = new Binding(root, null, jTree, "root");
  // For all nodes of type Manager, use the 'reports' property to find
  // their children.
  binding.addChildBinding("${reports}", null)
         .setParameter(ParameterKeys.TREE_NODE_CLASS, Manager.class);
</pre>

  </body>
</html>
